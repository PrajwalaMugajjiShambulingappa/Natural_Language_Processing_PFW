# -*- coding: utf-8 -*-
"""Lab2-Assignment.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1DEPKznxNhtpHiwCaqjpNeR9udEF4rjv5
"""

#Upload the dataset
from google.colab import files
dataset = files.upload()

#Reading from the dataset
with open('Lab1-Dataset.txt') as f:
  dataset = f.read()

import re
def process_regex(dataset):

  # Regex implementation to replace British English Spellings for words that have an extra ‘u’ with American English spellings 
  text =  re.sub("\b([a-zA-Z]+)[^(?:y|p|s|t|h|f|\s)](our)(ed|ing|s|hood)*\b", '\1or\2', dataset)
  
  dataset_titles= {
     "Dr.": "Doctor",
      "Mr.": "Mister",
      "Ms.": "Miss",
      "Mrs." : "Misses"
      }

  # Replace titles with appropriate expansions of words
  for title, expansion in dataset_titles.items():
    txt = re.sub(title, expansion, text)
  
  #writing the above outputs to regex.txt file
  with open("regex.txt", "w") as f:
    f.write(txt)
  f.close()

process_regex(dataset)

with open('regex.txt', 'r') as f:
    processed_text = f.read()

# Normalization
def normalize_text(processed_text):
  
  # Finding and replacing all the uppercase words into lowercase
  for f in re.findall("([A-Z]+)", processed_text):
    processed_text = processed_text.replace(f, f.lower())
  #print(processed_text)

  # Replacing all the special characters, numbers and punctions 
  processed_text = re.sub(r"[^\w\s]", " ", processed_text)
  #print(processed_text)

  # Removing reccusing words
  recurring_words = ['the','of','in','by','and', 'is', 'this', 'at', 'or', 'that', 'for', 'with', 'it', 'are', 'to']
  for word in recurring_words:
    processed_text = re.sub("\b" + word + "\b", "",processed_text, flags=re.IGNORECASE)
  
  # Tokenizing the text
  processed_text = re.split("\W", processed_text)
  
  # Writing the processed tokens into dictionary.txt file
  with open("dictionary.txt", 'w') as f:
   for word in processed_text:
     f.write(word + "\n ")
  f.close()

normalize_text(processed_text)

# with open("dictionary.txt", "r") as f:
#     processed_text = f.read()

# Minimum edit distance algorithm
def edit_distance_algo(X, Y):
  
  #getting lenght of both the strings
  n = len(X)
  m = len(Y)

  # Initializing a 2-D matrix of (0,0) to represent the distance
  distance_btwn_strings = []
  for i in range(n+1):
    row = []
    for j in range(m+1):
        row.append(i+j)
    
    distance_btwn_strings.append(row)
    
  #initilizing
  for i in range(n):
    distance_btwn_strings[i][0] = i
  for j in range(m):
    distance_btwn_strings[0][j] = j

  # implemnting the Recurrence Relation: 
  for i in range(1, n+1):
    for j in range(1, m+1):
      if X[i-1] == Y[j-1]:
        d=0
      else:
        d=2
      distance_btwn_strings [i][j]  = min (distance_btwn_strings[i-1][j]+1, distance_btwn_strings[i][j-1]+1, distance_btwn_strings[i-1][j-1]+d)

  edit_score = distance_btwn_strings[n][m]
  return edit_score
  

# Adding spell checker  
def spell_checker():
  with open("dictionary.txt", "r") as f:
        dictionary_text = f.read()
  
  dictionary_words = dictionary_text.split("\n")
  #print(dictionary_words)
  
  print("Welcome to the spell check!")
  print("Please enter a text to check spelling or enter quit to exit the program")

  # Taking user input string.
  sentence = input("Enter text to be checked: \n")

    # Replacing all the upper case to lower case.
  for f in re.findall("([A-Z]+)", sentence):
    sentence = processed_text.replace(f, f.lower())

  # Replacing all the special characters, numbers and punctions
  sentence = re.sub(r'[^\w\s]', '', sentence)

  user_spelt_words = re.split("\s", sentence)

  closest_word = []
  for speltword in user_spelt_words:
    # user input 'quit' terminates the program
      if speltword == "quit":
        print("Goodbye!")
        exit()
      if speltword in dictionary_words:
        # if the user input token is present in the dictionary, no misspellings are detected.
        print('No misspellings detected!')
        exit()
      if speltword not in dictionary_words:
        # if the user input token is not present in the dictionary, edit distance is calculated.
          min_distance = float('inf')
          for speltword1 in dictionary_words:
              distance = edit_distance_algo(speltword1, speltword)
              if distance < min_distance:
                  min_distance = distance
                  closest_word.append(speltword1)

  return closest_word


corrected_word = spell_checker()

print("Did you mean: \n", corrected_word)